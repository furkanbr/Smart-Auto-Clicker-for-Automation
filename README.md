# Smart Auto Clicker For Automation Documentation

This script automates the process of downloading PDF reports from the Prior Holter software. It uses a series of predefined orders to perform actions such as clicking buttons, pressing keys, and waiting for specific elements to appear on the screen. The script is designed to run in a loop, allowing it to process multiple reports in a single run.

## How it works

The script is divided into several sections:

1. **Importing necessary libraries**: The script imports the required libraries, such as `time`, `classes`, and `os`.

2. **Defining orders**: The `orders` dictionary contains the definitions of all the actions that need to be performed in the automation process. Each order is represented by a dictionary with two keys: `type` and `parameters`. The `type` key specifies the class of the action (e.g., `classes.KeyPress`, `classes.ButtonClick`, etc.), while the `parameters` key contains a dictionary of the parameters required for the action.

3. **Creating order objects**: The script iterates through the `orders` dictionary and creates an object for each order using the specified class and parameters. These objects are stored in the `order_objects` list.

4. **Loop limiter section**: The script sets up a loop counter and a loop limit. The loop counter is used to keep track of the number of loops completed, while the loop limit determines the maximum number of loops that the script will run. The `is_loop_limited` variable is used to control whether the script should run indefinitely or stop after a certain number of loops.

5. **Main loop**: The script enters a loop where it iterates through the `order_objects` list and calls the `work()` method on each order object. This method performs the action associated with the order (e.g., clicking a button, pressing a key, etc.). After each action is completed, the script prints a message indicating that the order has been executed. The loop continues until the loop counter reaches the loop limit or the `is_loop_limited` variable is set to `False`.

6. **End of the loop**: Once the loop is finished, the script prints a message indicating the total number of loops completed.

## Example output

Here's an example of the output generated by the script:

```
0 loops is done so far.
Order: 'Press 'Enter' Key' is done.
Order: 'Click 'Report' Button' is done.
Order: 'Click 'PDF+DICOM' Button' is done.
...
Order: 'Press 'Down' Key' is done.
1 loops is done so far.
Order: 'Press 'Enter' Key' is done.
Order: 'Click 'Report' Button' is done.
Order: 'Click 'PDF+DICOM' Button' is done.
...
Order: 'Press 'Down' Key' is done.
End of the loop. 2 loops were made at total.
```

This output shows that the script has completed two loops, executing each order in the `order_objects` list during each loop.


# Classes Documentation

In this class, several classes are defined to automate tasks using the PyAutoGUI library. These classes are designed to perform various actions such as clicking buttons, pressing keys, and waiting for specific images to appear or disappear on the screen. Below is the documentation for each class and its functions.

## 1. ButtonClick class

This class is used to perform a single click on a button or an image on the screen. It takes several optional parameters to customize its behavior, such as sleep time, waiting conditions, and security functions.

- `work()`: This method performs the actual click action. It first waits for the specified sleep time, then locates the center of the image on the screen, and finally moves the mouse to the coordinates and clicks. If the image is not found, it retries after a specified interval.

## 2. ButtonDoubleClick class

This class is similar to the `ButtonClick` class but performs a double-click action instead of a single click.

- `work()`: This method performs the double-click action. It follows the same process as the `ButtonClick` class, but calls the `doubleClick()` method instead of the `click()` method.

## 3. ButtonClickRelative class

This class is used to perform a click action relative to the current mouse position. It takes additional parameters for the x and y offsets to move the mouse before clicking.

- `work()`: This method performs the click action relative to the current mouse position. It first moves the mouse by the specified x and y offsets, then performs the click action.

## 4. KeyPress class

This class is used to simulate a key press action. It takes a key parameter to specify which key to press.

- `work()`: This method performs the key press action. It first waits for the specified sleep time, then presses and releases the specified key.

## 5. HotKeyPress class

This class is used to simulate a hotkey press action, which involves pressing two keys simultaneously. It takes two key parameters to specify the keys to press.

- `work()`: This method performs the hotkey press action. It first waits for the specified sleep time, then presses the two specified keys simultaneously.

## 6. WaitUntilAppear class

This class is used to wait until a specific image appears on the screen. It takes several optional parameters to customize its behavior, such as sleep time, waiting conditions, and time limits.

- `work()`: This method waits for the specified image to appear on the screen. It first waits for the specified sleep time, then continuously checks if the image is present on the screen. If the image is found, it breaks the loop and continues with the next action.

## 7. WaitUntilGone class

This class is used to wait until a specific image disappears from the screen. It takes similar optional parameters as the `WaitUntilAppear` class.

- `work()`: This method waits for the specified image to disappear from the screen. It first waits for the specified sleep time, then continuously checks if the image is still present on the screen. If the image is gone, it breaks the loop and continues with the next action.

These classes can be used together to create a sequence of automated actions using the PyAutoGUI library. The user can customize the behavior of each action by providing the appropriate parameters, such as sleep times, waiting conditions, and security functions.
